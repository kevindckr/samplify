import os
import sys
import time
import numpy as np
import multiprocessing
from typing import Generator, List, Optional, Dict, Tuple, Any, TypeVar

import numba
from numba import jit, prange
#@jit(nopython=True)


""" ---------------------------------------------
Numba implementations
--------------------------------------------- """

def footprint_validity_numba(image_size: Tuple[int, int], train_cpls: np.ndarray, test_cpls: np.ndarray, patch_bboxes: np.ndarray):
    """
    Calculate the valid/invalid pixels of the train and test footprints generated by the provided cpls.

    ~0.7s for Image size [1000, 2000] Patch size: [15, 15] (with train_cpls total coverage and 0.7% test cpl coverage)
    """
    # Combine the footprints
    train_footprint = generate_footprint_numba(image_size[0], image_size[1], train_cpls, patch_bboxes)
    test_footprint = generate_footprint_numba(image_size[0], image_size[1], test_cpls, patch_bboxes)

    # Compute invalid and valid pixels
    invalid_pixels = np.where((train_footprint > 0) & (test_footprint > 0))
    valid_test_pixels = np.where((train_footprint == 0) & (test_footprint > 0))
    valid_train_pixels = np.where((train_footprint > 0) & (test_footprint == 0))

    # Convert locations to np.ndarrays 
    invalid_pixels = np.column_stack(invalid_pixels)
    valid_test_pixels = np.column_stack(valid_test_pixels)
    valid_train_pixels = np.column_stack(valid_train_pixels)

    return invalid_pixels, valid_test_pixels, valid_train_pixels

def generate_footprint_numba(image_y: int, image_x: int, cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of cpls, calculate their footprint """
    footprint = np.zeros((image_y, image_x), dtype=np.int8)
    for y, x in cpls:
        ty, tx, by, bx = patch_bboxes[y, x]
        footprint[ty:by, tx:bx] = 1
    return footprint

@jit(nopython=True, parallel=True)
def generate_footprint_numba_parallel(image_y: int, image_x: int, cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of cpls, calculate their footprint """
    footprint = np.zeros((image_y, image_x), dtype=np.int8)
    for i in prange(cpls.shape[0]):
        y, x = cpls[i]
        ty, tx, by, bx = patch_bboxes[y, x]
        footprint[ty:by, tx:bx] = 1
    return footprint

def cpl_validity_numba(image_size: Tuple[int, int], train_cpls: np.ndarray, test_cpls: np.ndarray, patch_bboxes: np.ndarray):
    """
    Calculate the valid/invalid pixels of the train and test footprints generated by the provided cpls. Also 
    determine which train and test cpls generate those invalid pixels.

    ~0.7s for Image size [1000, 2000] Patch size: [15, 15]  (with train_cpls total coverage and 0.7% test cpl coverage)
    """
    # Combine the footprints
    train_footprint = generate_footprint_numba(image_size[0], image_size[1], train_cpls, patch_bboxes)
    test_footprint = generate_footprint_numba(image_size[0], image_size[1], test_cpls, patch_bboxes)

    # Compute invalid and valid pixels
    invalid_pixels = np.where((train_footprint > 0) & (test_footprint > 0))
    valid_test_pixels = np.where((train_footprint == 0) & (test_footprint > 0))
    valid_train_pixels = np.where((train_footprint > 0) & (test_footprint == 0))

    # Create a mask for all invalid pixel locations
    invalid_pixels_mask = np.zeros(image_size, dtype=bool)
    invalid_pixels_mask[invalid_pixels] = True

    # Combine the cpl validity by appending
    train_cpl_validity = check_cpl_validity_numba(invalid_pixels_mask, train_cpls, patch_bboxes)
    test_cpl_validity = check_cpl_validity_numba(invalid_pixels_mask, test_cpls, patch_bboxes)

    # Use the cpl validity arrays for train and test to get the valid and invalid for both
    valid_train_cpls = train_cpls[train_cpl_validity]
    invalid_train_cpls = train_cpls[~train_cpl_validity]
    valid_test_cpls = test_cpls[test_cpl_validity]
    invalid_test_cpls = test_cpls[~test_cpl_validity]

    # Convert locations to np.ndarrays 
    invalid_pixels = np.column_stack(invalid_pixels)
    valid_test_pixels = np.column_stack(valid_test_pixels)
    valid_train_pixels = np.column_stack(valid_train_pixels)

    return invalid_pixels, valid_train_pixels, valid_train_cpls, invalid_train_cpls, valid_test_pixels, valid_test_cpls, invalid_test_cpls

@jit(nopython=True)
def check_cpl_validity_numba(invalid_pixels_mask: np.ndarray, cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of invalid pixel locations and cpls, determine cpl validity """
    cpl_validity = np.ones(len(cpls), dtype=np.bool_)
    for idx, (y, x) in enumerate(cpls):
        ty, tx, by, bx = patch_bboxes[y, x]
        if np.any(invalid_pixels_mask[ty:by, tx:bx]):
            cpl_validity[idx] = False
    return cpl_validity

@jit(nopython=True, parallel=True)
def check_cpl_validity_numba_parallel(invalid_pixels_mask: np.ndarray, cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of invalid pixel locations and cpls, determine cpl validity """
    cpl_validity = np.ones(len(cpls), dtype=np.bool_)
    for idx in prange(len(cpls)):
        y, x = cpls[idx]
        ty, tx, by, bx = patch_bboxes[y, x]
        if np.any(invalid_pixels_mask[ty:by, tx:bx]):
            cpl_validity[idx] = False
    return cpl_validity

""" ---------------------------------------------
Multiprocessing implementations
--------------------------------------------- """

def footprint_validity_multiprocessing(image_size: Tuple[int, int], train_cpls: np.ndarray, test_cpls: np.ndarray, patch_bboxes: np.ndarray, max_cpus: int = 32):
    """
    Calculate the valid/invalid pixels of the train and test footprints generated by the provided cpls.

    ~2.5s for Image size [1000, 2000] Patch size: [15, 15] (with train_cpls total coverage and 0.7% test cpl coverage)
    """
    # Determine the number of cores to utilize
    num_cores = multiprocessing.cpu_count()
    num_cores = min(num_cores, max_cpus, 63)  # Consider Windows limit
    if len(train_cpls) < num_cores:
        num_cores = 1

    # Split CPLs into roughly equal parts for each core
    train_cpls_split = np.array_split(train_cpls, num_cores)
    test_cpls_split = np.array_split(test_cpls, num_cores)

    # Create a multiprocessing pool to parallelize the operation over
    with multiprocessing.Pool(processes=num_cores) as pool:
        train_footprint_parts = pool.starmap(generate_footprint_multiprocessing, [(image_size, subset, patch_bboxes) for subset in train_cpls_split])
        test_footprint_parts = pool.starmap(generate_footprint_multiprocessing, [(image_size, subset, patch_bboxes) for subset in test_cpls_split])

    # Combine the footprints
    train_footprint = np.sum(np.array(train_footprint_parts), axis=0)
    test_footprint = np.sum(np.array(test_footprint_parts), axis=0)

    # Compute invalid and valid pixels
    invalid_pixels = np.where((train_footprint > 0) & (test_footprint > 0))
    valid_test_pixels = np.where((train_footprint == 0) & (test_footprint > 0))
    valid_train_pixels = np.where((train_footprint > 0) & (test_footprint == 0))

    # Convert locations to np.ndarrays 
    invalid_pixels = np.column_stack(invalid_pixels)
    valid_test_pixels = np.column_stack(valid_test_pixels)
    valid_train_pixels = np.column_stack(valid_train_pixels)

    return invalid_pixels, valid_test_pixels, valid_train_pixels

def generate_footprint_multiprocessing(image_size: Tuple[int, int], cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of cpls, calculate their footprint """
    footprint = np.zeros(image_size, dtype=np.int8)
    for y, x in cpls:
        ty, tx, by, bx = patch_bboxes[y, x]
        footprint[ty:by, tx:bx] = 1
    return footprint

def cpl_validity_multiprocessing(image_size: Tuple[int, int], train_cpls: np.ndarray, test_cpls: np.ndarray, patch_bboxes: np.ndarray, max_cpus: int = 32):
    """
    Calculate the valid/invalid pixels of the train and test footprints generated by the provided cpls. Also 
    determine which train and test cpls generate those invalid pixels.

    ~5.0s for Image size [1000, 2000] Patch size: [15, 15]  (with train_cpls total coverage and 0.7% test cpl coverage)
    """
    # Determine the number of cores to utilize
    num_cores = multiprocessing.cpu_count()
    num_cores = min(num_cores, max_cpus, 63)  # Consider Windows limit
    if len(train_cpls) < num_cores or len(test_cpls) < num_cores:
        num_cores = 1

    # Split CPLs into roughly equal parts for each core
    train_cpls_split = np.array_split(train_cpls, num_cores)
    test_cpls_split = np.array_split(test_cpls, num_cores)

    # Create a multiprocessing pool to parallelize operation over
    with multiprocessing.Pool(processes=num_cores) as pool:
        train_footprint_parts = pool.starmap(generate_footprint_multiprocessing, [(image_size, subset, patch_bboxes) for subset in train_cpls_split])
        test_footprint_parts = pool.starmap(generate_footprint_multiprocessing, [(image_size, subset, patch_bboxes) for subset in test_cpls_split])

    # Combine the footprints 
    train_footprint = np.sum(np.array(train_footprint_parts), axis=0)
    test_footprint = np.sum(np.array(test_footprint_parts), axis=0)

    # Compute invalid and valid pixels
    invalid_pixels = np.where((train_footprint > 0) & (test_footprint > 0))
    valid_test_pixels = np.where((train_footprint == 0) & (test_footprint > 0))
    valid_train_pixels = np.where((train_footprint > 0) & (test_footprint == 0))

    # Create a mask for all invalid pixel locations
    invalid_pixels_mask = np.zeros(image_size, dtype=bool)
    invalid_pixels_mask[invalid_pixels] = True

    # Create a multiprocessing pool to parallelize operation over
    with multiprocessing.Pool(processes=num_cores) as pool:
        train_cpl_validity_parts = pool.starmap(check_cpl_validity_multiprocessing, [(invalid_pixels_mask, subset, patch_bboxes) for subset in train_cpls_split])
        test_cpl_validity_parts = pool.starmap(check_cpl_validity_multiprocessing, [(invalid_pixels_mask, subset, patch_bboxes) for subset in test_cpls_split])

    # Combine the cpl validity by appending
    train_cpl_validity = np.concatenate(train_cpl_validity_parts)
    test_cpl_validity = np.concatenate(test_cpl_validity_parts)

    # Use the cpl validity arrays for train and test to get the valid and invalid for both
    valid_train_cpls = train_cpls[train_cpl_validity]
    invalid_train_cpls = train_cpls[~train_cpl_validity]
    valid_test_cpls = test_cpls[test_cpl_validity]
    invalid_test_cpls = test_cpls[~test_cpl_validity]

    # Convert locations to np.ndarrays 
    invalid_pixels = np.column_stack(invalid_pixels)
    valid_test_pixels = np.column_stack(valid_test_pixels)
    valid_train_pixels = np.column_stack(valid_train_pixels)

    return invalid_pixels, valid_train_pixels, valid_train_cpls, invalid_train_cpls, valid_test_pixels, valid_test_cpls, invalid_test_cpls

def check_cpl_validity_multiprocessing(invalid_pixels_mask: np.ndarray, cpls: np.ndarray, patch_bboxes: np.ndarray):
    """ Given a set of invalid pixel locations and cpls, determine cpl validity """
    cpl_validity = np.ones(len(cpls), dtype=np.bool_)
    for idx, (y, x) in enumerate(cpls):
        ty, tx, by, bx = patch_bboxes[y, x]
        if np.any(invalid_pixels_mask[ty:by, tx:bx]):
            cpl_validity[idx] = False
    return cpl_validity
